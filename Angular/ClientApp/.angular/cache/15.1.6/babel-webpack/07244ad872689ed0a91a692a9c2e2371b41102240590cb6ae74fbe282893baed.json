{"ast":null,"code":"//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n/* tslint:disable */\n/* eslint-disable */\n// ReSharper disable InconsistentNaming\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\nimport { InjectionToken } from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport const API_BASE_URL = new InjectionToken('API_BASE_URL');\nexport class DepartmentClient {\n  constructor(http, baseUrl) {\n    this.jsonParseReviver = undefined;\n    this.http = http;\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n  }\n  /**\r\n   * @return Success\r\n   */\n  departmentAll() {\n    let url_ = this.baseUrl + \"/api/Department\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"text/plain\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processDepartmentAll(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processDepartmentAll(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processDepartmentAll(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @param body (optional)\r\n   * @return Success\r\n   */\n  departmentPOST(body) {\n    let url_ = this.baseUrl + \"/api/Department\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    const content_ = JSON.stringify(body);\n    let options_ = {\n      body: content_,\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Content-Type\": \"application/json\"\n      })\n    };\n    return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processDepartmentPOST(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processDepartmentPOST(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processDepartmentPOST(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return _observableOf(null);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @return Success\r\n   */\n  departmentGET(departmentId) {\n    let url_ = this.baseUrl + \"/api/Department/{departmentId}\";\n    if (departmentId === undefined || departmentId === null) throw new Error(\"The parameter 'departmentId' must be defined.\");\n    url_ = url_.replace(\"{departmentId}\", encodeURIComponent(\"\" + departmentId));\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"text/plain\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processDepartmentGET(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processDepartmentGET(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processDepartmentGET(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @param body (optional)\r\n   * @return Success\r\n   */\n  departmentPUT(departmentId, body) {\n    let url_ = this.baseUrl + \"/api/Department/{departmentId}\";\n    if (departmentId === undefined || departmentId === null) throw new Error(\"The parameter 'departmentId' must be defined.\");\n    url_ = url_.replace(\"{departmentId}\", encodeURIComponent(\"\" + departmentId));\n    url_ = url_.replace(/[?&]$/, \"\");\n    const content_ = JSON.stringify(body);\n    let options_ = {\n      body: content_,\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Content-Type\": \"application/json\"\n      })\n    };\n    return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processDepartmentPUT(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processDepartmentPUT(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processDepartmentPUT(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return _observableOf(null);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @return Success\r\n   */\n  departmentDELETE(departmentId) {\n    let url_ = this.baseUrl + \"/api/Department/{departmentId}\";\n    if (departmentId === undefined || departmentId === null) throw new Error(\"The parameter 'departmentId' must be defined.\");\n    url_ = url_.replace(\"{departmentId}\", encodeURIComponent(\"\" + departmentId));\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({})\n    };\n    return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processDepartmentDELETE(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processDepartmentDELETE(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processDepartmentDELETE(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return _observableOf(null);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n}\nDepartmentClient.ɵfac = function DepartmentClient_Factory(t) {\n  return new (t || DepartmentClient)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n};\nDepartmentClient.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: DepartmentClient,\n  factory: DepartmentClient.ɵfac,\n  providedIn: 'root'\n});\nexport class EmployeeClient {\n  constructor(http, baseUrl) {\n    this.jsonParseReviver = undefined;\n    this.http = http;\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\n  }\n  /**\r\n   * @return Success\r\n   */\n  employeeAll() {\n    let url_ = this.baseUrl + \"/api/Employee\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"text/plain\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processEmployeeAll(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processEmployeeAll(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processEmployeeAll(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @param body (optional)\r\n   * @return Success\r\n   */\n  employeePOST(body) {\n    let url_ = this.baseUrl + \"/api/Employee\";\n    url_ = url_.replace(/[?&]$/, \"\");\n    const content_ = JSON.stringify(body);\n    let options_ = {\n      body: content_,\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Content-Type\": \"application/json\"\n      })\n    };\n    return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processEmployeePOST(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processEmployeePOST(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processEmployeePOST(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return _observableOf(null);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @return Success\r\n   */\n  employeeGET(employeeId) {\n    let url_ = this.baseUrl + \"/api/Employee/{employeeId}\";\n    if (employeeId === undefined || employeeId === null) throw new Error(\"The parameter 'employeeId' must be defined.\");\n    url_ = url_.replace(\"{employeeId}\", encodeURIComponent(\"\" + employeeId));\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Accept\": \"text/plain\"\n      })\n    };\n    return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processEmployeeGET(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processEmployeeGET(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processEmployeeGET(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        let result200 = null;\n        result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver);\n        return _observableOf(result200);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @param body (optional)\r\n   * @return Success\r\n   */\n  employeePUT(employeeId, body) {\n    let url_ = this.baseUrl + \"/api/Employee/{employeeId}\";\n    if (employeeId === undefined || employeeId === null) throw new Error(\"The parameter 'employeeId' must be defined.\");\n    url_ = url_.replace(\"{employeeId}\", encodeURIComponent(\"\" + employeeId));\n    url_ = url_.replace(/[?&]$/, \"\");\n    const content_ = JSON.stringify(body);\n    let options_ = {\n      body: content_,\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({\n        \"Content-Type\": \"application/json\"\n      })\n    };\n    return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processEmployeePUT(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processEmployeePUT(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processEmployeePUT(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return _observableOf(null);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n  /**\r\n   * @return Success\r\n   */\n  employeeDELETE(employeeId) {\n    let url_ = this.baseUrl + \"/api/Employee/{employeeId}\";\n    if (employeeId === undefined || employeeId === null) throw new Error(\"The parameter 'employeeId' must be defined.\");\n    url_ = url_.replace(\"{employeeId}\", encodeURIComponent(\"\" + employeeId));\n    url_ = url_.replace(/[?&]$/, \"\");\n    let options_ = {\n      observe: \"response\",\n      responseType: \"blob\",\n      headers: new HttpHeaders({})\n    };\n    return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap(response_ => {\n      return this.processEmployeeDELETE(response_);\n    })).pipe(_observableCatch(response_ => {\n      if (response_ instanceof HttpResponseBase) {\n        try {\n          return this.processEmployeeDELETE(response_);\n        } catch (e) {\n          return _observableThrow(e);\n        }\n      } else return _observableThrow(response_);\n    }));\n  }\n  processEmployeeDELETE(response) {\n    const status = response.status;\n    const responseBlob = response instanceof HttpResponse ? response.body : response.error instanceof Blob ? response.error : undefined;\n    let _headers = {};\n    if (response.headers) {\n      for (let key of response.headers.keys()) {\n        _headers[key] = response.headers.get(key);\n      }\n    }\n    if (status === 200) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return _observableOf(null);\n      }));\n    } else if (status !== 200 && status !== 204) {\n      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {\n        return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\n      }));\n    }\n    return _observableOf(null);\n  }\n}\nEmployeeClient.ɵfac = function EmployeeClient_Factory(t) {\n  return new (t || EmployeeClient)(i0.ɵɵinject(HttpClient), i0.ɵɵinject(API_BASE_URL, 8));\n};\nEmployeeClient.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: EmployeeClient,\n  factory: EmployeeClient.ɵfac,\n  providedIn: 'root'\n});\nexport class ApiException extends Error {\n  constructor(message, status, response, headers, result) {\n    super();\n    this.isApiException = true;\n    this.message = message;\n    this.status = status;\n    this.response = response;\n    this.headers = headers;\n    this.result = result;\n  }\n  static isApiException(obj) {\n    return obj.isApiException === true;\n  }\n}\nfunction throwException(message, status, response, headers, result) {\n  if (result !== null && result !== undefined) return _observableThrow(result);else return _observableThrow(new ApiException(message, status, response, headers, null));\n}\nfunction blobToText(blob) {\n  return new Observable(observer => {\n    if (!blob) {\n      observer.next(\"\");\n      observer.complete();\n    } else {\n      let reader = new FileReader();\n      reader.onload = event => {\n        observer.next(event.target.result);\n        observer.complete();\n      };\n      reader.readAsText(blob);\n    }\n  });\n}","map":{"version":3,"mappings":"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","names":["mergeMap","_observableMergeMap","catchError","_observableCatch","Observable","throwError","_observableThrow","of","_observableOf","InjectionToken","HttpClient","HttpHeaders","HttpResponse","HttpResponseBase","API_BASE_URL","DepartmentClient","constructor","http","baseUrl","undefined","departmentAll","url_","replace","options_","observe","responseType","headers","request","pipe","response_","processDepartmentAll","e","response","status","responseBlob","body","error","Blob","_headers","key","keys","get","blobToText","_responseText","result200","JSON","parse","jsonParseReviver","throwException","departmentPOST","content_","stringify","processDepartmentPOST","departmentGET","departmentId","Error","encodeURIComponent","processDepartmentGET","departmentPUT","processDepartmentPUT","departmentDELETE","processDepartmentDELETE","factory","providedIn","EmployeeClient","employeeAll","processEmployeeAll","employeePOST","processEmployeePOST","employeeGET","employeeId","processEmployeeGET","employeePUT","processEmployeePUT","employeeDELETE","processEmployeeDELETE","ApiException","message","result","isApiException","obj","blob","observer","next","complete","reader","FileReader","onload","event","target","readAsText"],"sourceRoot":"","sources":["C:\\Users\\princz\\source\\repos\\Angular\\Angular\\ClientApp\\src\\app\\api\\app.generated.ts"],"sourcesContent":["//----------------------\r\n// <auto-generated>\r\n//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\r\n// </auto-generated>\r\n//----------------------\r\n\r\n/* tslint:disable */\r\n/* eslint-disable */\r\n// ReSharper disable InconsistentNaming\r\n\r\nimport { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';\r\nimport { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';\r\nimport { Injectable, Inject, Optional, InjectionToken } from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';\r\n\r\nexport const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class DepartmentClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    departmentAll(): Observable<DepartmentDto[]> {\r\n        let url_ = this.baseUrl + \"/api/Department\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDepartmentAll(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDepartmentAll(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<DepartmentDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<DepartmentDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processDepartmentAll(response: HttpResponseBase): Observable<DepartmentDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DepartmentDto[];\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional) \r\n     * @return Success\r\n     */\r\n    departmentPOST(body: DepartmentCreateOrUpdateDto | undefined): Observable<void> {\r\n        let url_ = this.baseUrl + \"/api/Department\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDepartmentPOST(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDepartmentPOST(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<void>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<void>;\r\n        }));\r\n    }\r\n\r\n    protected processDepartmentPOST(response: HttpResponseBase): Observable<void> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return _observableOf(null as any);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    departmentGET(departmentId: number): Observable<DepartmentDto> {\r\n        let url_ = this.baseUrl + \"/api/Department/{departmentId}\";\r\n        if (departmentId === undefined || departmentId === null)\r\n            throw new Error(\"The parameter 'departmentId' must be defined.\");\r\n        url_ = url_.replace(\"{departmentId}\", encodeURIComponent(\"\" + departmentId));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDepartmentGET(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDepartmentGET(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<DepartmentDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<DepartmentDto>;\r\n        }));\r\n    }\r\n\r\n    protected processDepartmentGET(response: HttpResponseBase): Observable<DepartmentDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DepartmentDto;\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional) \r\n     * @return Success\r\n     */\r\n    departmentPUT(departmentId: number, body: DepartmentCreateOrUpdateDto | undefined): Observable<void> {\r\n        let url_ = this.baseUrl + \"/api/Department/{departmentId}\";\r\n        if (departmentId === undefined || departmentId === null)\r\n            throw new Error(\"The parameter 'departmentId' must be defined.\");\r\n        url_ = url_.replace(\"{departmentId}\", encodeURIComponent(\"\" + departmentId));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDepartmentPUT(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDepartmentPUT(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<void>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<void>;\r\n        }));\r\n    }\r\n\r\n    protected processDepartmentPUT(response: HttpResponseBase): Observable<void> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return _observableOf(null as any);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    departmentDELETE(departmentId: number): Observable<void> {\r\n        let url_ = this.baseUrl + \"/api/Department/{departmentId}\";\r\n        if (departmentId === undefined || departmentId === null)\r\n            throw new Error(\"The parameter 'departmentId' must be defined.\");\r\n        url_ = url_.replace(\"{departmentId}\", encodeURIComponent(\"\" + departmentId));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processDepartmentDELETE(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processDepartmentDELETE(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<void>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<void>;\r\n        }));\r\n    }\r\n\r\n    protected processDepartmentDELETE(response: HttpResponseBase): Observable<void> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return _observableOf(null as any);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\n@Injectable({\r\n    providedIn: 'root'\r\n})\r\nexport class EmployeeClient {\r\n    private http: HttpClient;\r\n    private baseUrl: string;\r\n    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;\r\n\r\n    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {\r\n        this.http = http;\r\n        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : \"\";\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    employeeAll(): Observable<EmployeeListDto[]> {\r\n        let url_ = this.baseUrl + \"/api/Employee\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processEmployeeAll(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processEmployeeAll(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<EmployeeListDto[]>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<EmployeeListDto[]>;\r\n        }));\r\n    }\r\n\r\n    protected processEmployeeAll(response: HttpResponseBase): Observable<EmployeeListDto[]> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EmployeeListDto[];\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional) \r\n     * @return Success\r\n     */\r\n    employeePOST(body: EmployeeCreateDto | undefined): Observable<void> {\r\n        let url_ = this.baseUrl + \"/api/Employee\";\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"post\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processEmployeePOST(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processEmployeePOST(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<void>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<void>;\r\n        }));\r\n    }\r\n\r\n    protected processEmployeePOST(response: HttpResponseBase): Observable<void> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return _observableOf(null as any);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    employeeGET(employeeId: number): Observable<EmployeeDetailsDto> {\r\n        let url_ = this.baseUrl + \"/api/Employee/{employeeId}\";\r\n        if (employeeId === undefined || employeeId === null)\r\n            throw new Error(\"The parameter 'employeeId' must be defined.\");\r\n        url_ = url_.replace(\"{employeeId}\", encodeURIComponent(\"\" + employeeId));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Accept\": \"text/plain\"\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"get\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processEmployeeGET(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processEmployeeGET(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<EmployeeDetailsDto>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<EmployeeDetailsDto>;\r\n        }));\r\n    }\r\n\r\n    protected processEmployeeGET(response: HttpResponseBase): Observable<EmployeeDetailsDto> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            let result200: any = null;\r\n            result200 = _responseText === \"\" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EmployeeDetailsDto;\r\n            return _observableOf(result200);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @param body (optional) \r\n     * @return Success\r\n     */\r\n    employeePUT(employeeId: number, body: EmployeeUpdateDto | undefined): Observable<void> {\r\n        let url_ = this.baseUrl + \"/api/Employee/{employeeId}\";\r\n        if (employeeId === undefined || employeeId === null)\r\n            throw new Error(\"The parameter 'employeeId' must be defined.\");\r\n        url_ = url_.replace(\"{employeeId}\", encodeURIComponent(\"\" + employeeId));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        const content_ = JSON.stringify(body);\r\n\r\n        let options_ : any = {\r\n            body: content_,\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n                \"Content-Type\": \"application/json\",\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"put\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processEmployeePUT(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processEmployeePUT(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<void>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<void>;\r\n        }));\r\n    }\r\n\r\n    protected processEmployeePUT(response: HttpResponseBase): Observable<void> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return _observableOf(null as any);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n\r\n    /**\r\n     * @return Success\r\n     */\r\n    employeeDELETE(employeeId: number): Observable<void> {\r\n        let url_ = this.baseUrl + \"/api/Employee/{employeeId}\";\r\n        if (employeeId === undefined || employeeId === null)\r\n            throw new Error(\"The parameter 'employeeId' must be defined.\");\r\n        url_ = url_.replace(\"{employeeId}\", encodeURIComponent(\"\" + employeeId));\r\n        url_ = url_.replace(/[?&]$/, \"\");\r\n\r\n        let options_ : any = {\r\n            observe: \"response\",\r\n            responseType: \"blob\",\r\n            headers: new HttpHeaders({\r\n            })\r\n        };\r\n\r\n        return this.http.request(\"delete\", url_, options_).pipe(_observableMergeMap((response_ : any) => {\r\n            return this.processEmployeeDELETE(response_);\r\n        })).pipe(_observableCatch((response_: any) => {\r\n            if (response_ instanceof HttpResponseBase) {\r\n                try {\r\n                    return this.processEmployeeDELETE(response_ as any);\r\n                } catch (e) {\r\n                    return _observableThrow(e) as any as Observable<void>;\r\n                }\r\n            } else\r\n                return _observableThrow(response_) as any as Observable<void>;\r\n        }));\r\n    }\r\n\r\n    protected processEmployeeDELETE(response: HttpResponseBase): Observable<void> {\r\n        const status = response.status;\r\n        const responseBlob =\r\n            response instanceof HttpResponse ? response.body :\r\n            (response as any).error instanceof Blob ? (response as any).error : undefined;\r\n\r\n        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}\r\n        if (status === 200) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return _observableOf(null as any);\r\n            }));\r\n        } else if (status !== 200 && status !== 204) {\r\n            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {\r\n            return throwException(\"An unexpected server error occurred.\", status, _responseText, _headers);\r\n            }));\r\n        }\r\n        return _observableOf(null as any);\r\n    }\r\n}\r\n\r\nexport interface DepartmentCreateOrUpdateDto {\r\n    name?: string | undefined;\r\n    abbreviation?: string | undefined;\r\n}\r\n\r\nexport interface DepartmentDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    abbreviation?: string | undefined;\r\n    lastModAt?: Date;\r\n    lastModBy?: string | undefined;\r\n    createdAt?: Date;\r\n    createdBy?: string | undefined;\r\n}\r\n\r\nexport interface EmployeeCreateDto {\r\n    name?: string | undefined;\r\n    position?: string | undefined;\r\n    phone?: string | undefined;\r\n    username?: string | undefined;\r\n    password?: string | undefined;\r\n    bossId?: number | undefined;\r\n    departmentId?: number;\r\n}\r\n\r\nexport interface EmployeeDetailsDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    position?: string | undefined;\r\n    phone?: string | undefined;\r\n    departmentId?: number;\r\n    departmentName?: string | undefined;\r\n    lastModAt?: Date;\r\n    lastModBy?: string | undefined;\r\n    createdAt?: Date;\r\n    createdBy?: string | undefined;\r\n    username?: string | undefined;\r\n    bossId?: number;\r\n    bossName?: string | undefined;\r\n}\r\n\r\nexport interface EmployeeListDto {\r\n    id?: number;\r\n    name?: string | undefined;\r\n    position?: string | undefined;\r\n    phone?: string | undefined;\r\n    departmentId?: number;\r\n    departmentName?: string | undefined;\r\n    lastModAt?: Date;\r\n    lastModBy?: string | undefined;\r\n    createdAt?: Date;\r\n    createdBy?: string | undefined;\r\n}\r\n\r\nexport interface EmployeeUpdateDto {\r\n    name?: string | undefined;\r\n    position?: string | undefined;\r\n    phone?: string | undefined;\r\n    bossId?: number | undefined;\r\n    departmentId?: number;\r\n}\r\n\r\nexport class ApiException extends Error {\r\n    override message: string;\r\n    status: number;\r\n    response: string;\r\n    headers: { [key: string]: any; };\r\n    result: any;\r\n\r\n    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {\r\n        super();\r\n\r\n        this.message = message;\r\n        this.status = status;\r\n        this.response = response;\r\n        this.headers = headers;\r\n        this.result = result;\r\n    }\r\n\r\n    protected isApiException = true;\r\n\r\n    static isApiException(obj: any): obj is ApiException {\r\n        return obj.isApiException === true;\r\n    }\r\n}\r\n\r\nfunction throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {\r\n    if (result !== null && result !== undefined)\r\n        return _observableThrow(result);\r\n    else\r\n        return _observableThrow(new ApiException(message, status, response, headers, null));\r\n}\r\n\r\nfunction blobToText(blob: any): Observable<string> {\r\n    return new Observable<string>((observer: any) => {\r\n        if (!blob) {\r\n            observer.next(\"\");\r\n            observer.complete();\r\n        } else {\r\n            let reader = new FileReader();\r\n            reader.onload = event => {\r\n                observer.next((event.target as any).result);\r\n                observer.complete();\r\n            };\r\n            reader.readAsText(blob);\r\n        }\r\n    });\r\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}